---
layout: fr
title: Riot 1.0
---

{% include guide-tabs.html %}

### **IMPORTANT** Cette version n'est plus maintenue

## Introduction à Riot 1.0

Riot est l'approche la plus minimale possible au monde du MVC. La bibliothèque pèse 1ko et a seulement 3 méthodes publiques, ce qui le rend extrêmement simple à apprendre. Une application Riot utilise du JavaScript vanilla pour structurer le code. Vous utiliserez des schémas de conception classiques au lieu d'idiomes spécifiques à certains frameworks.

Les applications Riot sont modulaires et peuvent être maintenues par de multiples développeurs. Sa nature [anti-framework](https://muut.com//blog/technology/frameworkless-javascript.html) vous force à vous concentrer sur le plus important: votre logique métier et l'API.

Pour une introduction plus approfondie, consultez le [post d'origine sur le blog](https://muut.com//blog/technology/riotjs-the-1kb-mvp-framework.html).


## Qu'est-ce qui est modulaire ?

Votre rôle est de construire des applications pouvant être décomposées en modules. Chaque module s'occupe d'une certaine fonction logique et n'est pas dépendant des autres modules. Cela apporte de gros avantages:

1. Un gros programme peut être cassé en plus petites et plus simples unités
2. Les modules peuvent être ajoutés/retirés/modifiés sans affecter les autres parties de l'application
3. Plusieurs programmeurs peuvent travailler sur des modules individuels en même temps
4. La structure du programme est simple à comprendre même pour les nouveaux venus
5. La capacité à construire un sous-ensemble de modules pour des besoins différents

La modularité est l'élément clé pour les applications de grande échelle. Fondamentalement, une application modulaire consiste en deux choses:

1. un noyau (Core)
2. des modules

Le noyau de l'application est un bout de logiciel avec une API bien documentée. Il ne s'agit pas juste d'une couche données, comme vous pouvez le voir sur certaines installations MVC – il s'agit de la précieuse logique métier.

Les modules sont les extensions à ce noyau. Ces modules sont "faiblement couplés", ce qui signifie qu'ils viennent se greffer au noyau en observant les événements émis par celui-ci. Ainsi, le noyau n'a pas connaissance de ces modules.

Il n'y a pas de références à des fonctions écrites en dur car le couplage fort fonctionne mal à plus grande échelle. Il peut y avoir des dépendances déclarées en dur dans le noyau, mais pas entre le noyau et les modules.

Garder les choses modulaires implique en fait une constante organisation du travail. Chaque chose doit être à sa place la plus logique. Faites l'analogie avec les calques dans Photoshop, la table des matières dans un livre ou la hiérarchie visuelle dans une interface utilisateur. C'est une recherche permanente d'équilibre. Et quand vous ajoutez des fonctionnalités, elles doivent trouver leur place dans le cadre.


## Modèle, Vue, et Présentation

Quand on parle de modularité dans des applications mono-page, mieux vaut mettre les choses à plat.

Avant tout, vous devez connaître les objectifs de votre application. Qu'est-ce que ça fait et qu'est-ce que ça ne fait pas ? Vous modélisez votre logique métier en JavaScript: c'est votre noyau applicatif. Aussi appelé *Modèle*.

Ensuite, vous avez le navigateur et l'interface utilisateur. Le HTML, le document (DOM) et le style (CSS). La partie que l'utilisateur voit et interagit avec. C'est la *Vue*.

Puis vous devez relier ces deux choses ensemble. Vous devez réagir aux événements survenant sur la Vue: clics, touches pressées, défilements... Vous devez aussi observer les changements du Modèle: peut-être qu'une nouvelle entrée est venue d'un canal temps réel, ou que quelqu'un a commenté un article. Ce composant doit observer tous ces événements et y réagir en conséquence.

Cet "entremetteur" constitue la couche dite de *Présentation*.

Riot utilise ces termes pour décrire Riot dans son ensemble: Modèle, Vue et Présentation (MVP).

Le MVP a comme objectif essentiel de séparer la logique applicative (Modèle) de l'interface utilisateur (Vue). Cette séparation est importante car elle simplifie votre code et le rend plus facilement testable. Ce manque de séparation à haut niveau cause ce qu'on appelle le "code spaghetti" où le métier et l'interface utilisateur sont mélangés entre eux. C'est l'ère jQuery avant que les applications mono-page aient commencé à gagner en popularité.

Dans la terminologie classique UI, Riot utilise la branche *Vue passive* [(1)](#links) de la famille MVP.

> L'approche Vue Passive réduit la logique comportementale des composants d'interface à son minimum en utilisant un contrôleur qui en plus de réagir aux événements utilisateur, se charge également de mettre à jour toute la vue.

Contrairement à la plupart des configurations MVC, la Vue Passive permet de n'avoir aucune dépendance entre la Vue et le Modèle. C'est un modèle de conception simple à comprendre et à implémenter – ce qui vous rend finalement plus performant.

Enfin, il est important de réaliser que MVP (ou MVC) n'est pas un framework. C'est un schéma de conception à haut niveau. Son but est de simplifier l'achitecture des applications aux interfaces chargées. C'est un moyen simple de structurer vitre code. Dans des applications à couplage faible, les modules communiquement les uns avec les autres avec des événements.

La plupart des frameworks actuels sont superflus car fondamentalement, tout ce dont vous avez besoin est un bon système d'événements.


## Modèle

Le Modèle est le noyau de l'application. C'est la partie la plus importante de votre application, car tout est construit par-dessus. C'est l'interface publique au reste du monde. Vous l'utiliserez, votre équipe l'utilisera, et des personnes tierces l'utiliseront.

Un noyau d'application bien conçu peut être étendu avec des modules à couplage faible et permet à chacun de développer soi-même le système.

Dans Riot, le modèle est une application complète et non juste un objet utilitaire pour la couche Présentation comme vous avez pu le voir sur des configurations MVC. C'est aussi une bonne pratique d'avoir des modèles assez gros comparés aux vues car au plus vous vous rapprochez de la vue, plus il devient difficile de tester le code. Tout ce qui est difficile à tester devrait avoir un comportement minimal.

Cela permet de développer de multiples interfaces utilisateur par-dessus le même Modèle. Prenez l'exemple de Twitter et de ses différents clients (du temps où tout allait bien avec eux). Les gens pourraient développer des expériences très différentes par-dessus la même API sans même se connaître.


### Concevoir le Modèle

Le Modèle est le point de départ de la conception d'une application (la Vue en est un autre, selon les préférences). Vous devriez vous réserver du temps pour concevoir le Modèle et le rendre le plus simple possible car vous passerez beaucoup de temps à l'utiliser ensuite. Mettez la barre très haut. Pensez à l'API jQuery par exemple.

Deux choses à garder en tête:

1. Quel problème résout le produit ?
2. Qui utilise le produit ?

Le Modèle est un domaine bien spécifique. Pensez à ce que votre application fait, quels sont les objectifs, quelles fonctionnalités sont présentes et lesquelles ne le sont *pas*. Décomposez votre business en pièces logoqies et réfléchissez à comment elles communiquent. Ce que vous avez déjà dû faire par le passé avec les langages orientés objet.

Gardez tout cela en mémoire lorsque vous concevez les propriétés, méthodes, événements. Sans aller plus loin, disons que l'API est la racine du bien et du mal.


### Backend (Serveur)

Riot n'inclut aucun composant serveur séparé. C'est un choix de conception. REST domine actuellement la façon de penser, mais les Web Sockets et les patterns temps réel sont juste au coin de la rue, et les protocoles de style RPC auront alors plus de sens.

Votre interface serveur peut juste avoir une méthode générique `call` afin que toute l'implémentation sous-jacente puisse changer. Peu importe qu'il s'agisse de REST, RPC ou d'un truc personnalisé en AJAX.


## Vue

La Vue est ce que l'utilisateur voit et interagit avec. C'est la page HTML sur un navigateur. Ce qui est en fait intéressant pour un développeur JavaScript est le modèle document (DOM). Vous pouvez utiliser toutes sortes d'astuces créatives pour concevoir des expériences utilisateur. Il s'agit surtout d'une source d'événements:

1. Evénements utilisateur: clics, défilements, touches pressées, souris déplacée etc...
2. Evénement "ready" du document
3. Changement d'URL

Ces événements présentent un intérêt pour la couche Présentation, qui s'occupe de la manipulation concrète de la vue. La vue en elle-même n'a pas de logique - juste du bon vieux code HTML et CSS.


## Presentation

La couche Présentation et l'important médiateur entre la Vue et le Modèle. Chaque Présentateur est un module faiblement couplé effectuant une fonction bien particulière et pouvant être développé individuellement du reste.

Le Présentateur écoute les événements de la Vue et appelle les méthodes appropriées côté API. Il écoute également les événements des Modèles et manipule le DOM en conséquence.

La couche Présentation ne fait aucune afirmation sur le modèle business.

<small>
Notez que d'autres frameworks peuvent appeler cette couche la "Vue", mais dans le modèle MVP on l'appelle bien Présentation.
</small>

### Templates

Parfois j'aime commencer développer une application mono-page avec juste du HTML et du CSS. C'est incroyable tout ce que vous pouvez faire avec juste ça. Vous pouvez peaufiner le design et l'interface utilisateur presque totalement. En ajoutant de simples noms de classes CSS en JavaScript, vous pouvez faire ces belles transitions de vues. En réalité, bien sûr vous ferez du JavaScript mais il est tout à fait possible de montrer au client l'interface complète d'une application sans une seule ligne de code logique.

Le mieux dans tout ça est que vous pouvez naturellement compléter cette vue HTML pour faire l'application entière. Idéalement, vous avez également complété l'API et il ne vous reste plus qu'à coder la couche Présentation pour les relier ensemble.

Ce déguisement HTML est une collection de templates. Avant de commencer avec la Présentation, vous pouvez déplacer certaines parties de ce HTML à l'intérieur de balises `<template/>` ou `<script type='text/template'/>` , typiquement celles qui seront amenées à être reproduites plusieurs fois à l'intérieur de boucles.


#### Pas de logique

Riot a une position forte qui est déconseiller de mettre de la logique à l'intérieur des templates. Il y a plusieurs raisons à cela:

1. Du HMTL pur est plus propre et passe le validateur W3C. Un HTML mélangé avec une syntaxe de templating est désordonné.

1. HTML n'a pas été conçu à la base pour décrire de la logique

1. Les boucles dans les templates ne sont pas nécessaires dans les applications temps réel où les listes itérables peuvent changer avec le temps. Il s'agit probablement du défi le plus important des langages de templates actuels.

1. La logique à l'intérieur du HTML est difficile voire impossible à tester

1. Les templates sans logique sont parfois plus rapides d'un ordre de grandeur, surtout sur les navigateurs sans Webkit [(2)](#links)

1. Dans les boucles complexes, il est naturel de laisser la logique de calcul des données à JavaScript et de garder les templates propres.

Regardez la logique de ce [listing client](https://github.com/riot/riot-admin/blob/master/src/ui/customers.js#L21). L'unique template est interprété plusieurs fois à l'intérieur d'une boucle et la propriété `width` est calculée en JavaScript pour garder le [template](https://github.com/riot/riot-admin/blob/master/index.html#L100) simple.


### Routage

L'application de démonstration gère le routage en couche présentation comme ceci:

``` javascript
// 1. Liens
app.root.on("click", "[href^='#/']", function(e) {
  riot.route($(this).attr("href"))
})


// 2. Routage (association entre les URL et les méthodes API)
riot.route(function(path) {
  app.load(path.slice(2))
})


// 3. Logique d'interface
app.on("before:load", function() {

  // supprime la classe existante
  $(".page.is-active").removeClass("is-active")

}).on("load", function(view) {

  // en met une autre
  $("#" + view.type + "-page").addClass("is-active")

})
```

Voilà comment cela fonctionne:

1. **Liens**: sélectionne les liens s'occupant de la bascule entre les vues et change l'URL. Nous utilisons les événements délégués jQuery pour récupérer à la demande tous les liens ancre de la page, même s'ils sont créés dynamiquement plus tard.

2. **Routage**: Définit la méthode API à appeler quand l'URL change. Cette application de démonstration a une suele méthode générique `load` prenant un nom de page en argument, mais vous pouvez avoir une association plus complexe entre les URL et les méthodes.

3. **Logique d'interface**: Définit ce qui se passe dans l'interface quand une méthode API est appelée et que des données (ou une "page") est retournée par le serveur. Ici nous assignons une classe CSS "is-active" pour animer la page en utilisant des transitions CSS.

L'API émét des événements "before:load" et "load" afin que la couche présentation puisse implémenter la logique de bascule de page via les gestionnaires d'événements. De cette façon, vous pouvez appeler la méthode `load` de l'API depuis la console aussi, et l'UI se comportera de la même manière qu'en cliquant sur les liens de navigation.

Le routage est l'une des choses principales qui définissent un framework côté client. Dans Riot, la fonction `riot.route` est une couche mince par-dessus l'API pour gérer le bouton Précédent. L'API peut se concentrer sur la logique métier sans se soucier de la couche web. Le routage côté présentation est complètement transparent et chacune des étapes peut être personnalisée selon les besoins de votre application.

Le code ci-dessus s'occupe uniquement de la bascule et le rendu de la page retournée est géré par un présentateur différent, spécifique à cette vue.


### jQuery

jQuery existe car les API natives pour manipuler le DOM sont désastreuses pour travailler. jQuery fait un nettoyage massif en exposant le DOM au développeur d'une manière élégante et amicale.

Il y a d'autres implémentations [(3)](#links), mais tout le crédit revient à John Resig. Il a conçu l'API, qui est devenue un standard.

Soyez libres d'utiliser une autre implémentation, mais les avantages de jQuery en lui-même sont:

- meilleur support multi-navigateur, incluant IE6
- sélecteurs et logique internes aux performances optimisées
- la plus grosse et plus fiable suite de tests
- sûrement déjà présent sur un site, possiblement en cache depuis un CDN

jQuery est actuellement présent sur 58% de tous les sites web et 93.0% de tous les sites web utilisant une bibliothèque JavaScript connue [(4)](#links). Ces nombres sont en croissance permanente.

L'API jQuery est une correspondance parfaite pour Riot. C'est l'outil ultime pour coder la couche Présentation. Les sélecteurs jQuery fournissent une manière non obstrusive de relier le modèle à la vue. Et il peut y avoir de multiples présnetateurs gérant le même ensemble d'éléments HTML sans avoir connaissance les uns des autres.

Les ID et les noms de classes fournissent des mécanismes naturels pour y associer des fonctionnalités, tout comme vous leur associez des styles en CSS. Souvenez-vous juste que si les ID et noms de classes changent, vous devrez également modifier le code des présentateurs.

<small>
Notez que riot n'est pas dépendant de jQuery. Vous pouvez utiliser d'autres bibliothèques DOM telles que DOJO ou MooTools ou vous pouvez utiliser React de Facebook.
</small>

## Module interface

Now let's focus on coding. We want a simple way to extend the application core with modules. Here's a nice `riot.observable` trick to split the application into loosely-coupled modules:


``` javascript
// make it work on client and server
var global = is_node ? exports : window,
  instance

// only single global variable is exposed
global.admin = riot.observable(function(arg) {

  // when called without argument, the API is returned
  if (!arg) return instance

  // function argument --> bind a new module
  if ($.isFunction(arg)) {
    admin.on("ready", arg)

  // configuration argument --> start the applicaiont
  } else {
    instance = new Admin(arg)

    instance.on("ready", function() {
      admin.trigger("ready", instance)
    })

  }

})
```

The above code exposes a single global variable `admin` that can be used as follows:

``` javascript
admin(function(api) {
  // module #1 logic, API is given as argument
})

admin(function(api) {
  // module #2 logic
})
```

All UI functionality on the demo application is wrapped inside modules like this. Now after you have all the code inside the modules you need to launch the application:


``` javascript
admin({ page: location.hash.slice(2), root: $("body") })
```

This will start the application with the configuration given on the argument and all the modules are initialized when the "ready" event is fired. This is typically called after the DOM has been loaded on the bottom of the page or inside jQuery's `document.ready`. The given argument typically contains the initial path of the application, as well as the root element. Your application has its own set of configuration variables, of course.

You can access the API after the initialization as follows:

``` javascript
var api = admin() // get access

api.load("customers") // call an API method, also try with "stats" for example
```

Try that on the JavaScript console on the demo (must be logged in)! All features that you can do with the UI are also available on the API. This is ensured by the strict separation of API and presenter modules.

Now your application is nicely split into decoupled modules and there is a simple way to add new modules. Each of your team members has only one, global `admin` method to use and the API is given as the first argument to each module. The modules are isolated and can be freely added / removed without breaking other parts of the application. You can have modules on both the API layer and the presenter layer.

Finally, the module interface is "white labeled". You can name the crucial module interface after your application and there is no 3rd party framework to force the naming scheme. Much cooler!


## Application lifecycle

When the application starts a sequence of events happen. Here is a typical flow:

1. The call to server is made to load the initial view data
2. The API is fully constructed
3. The modules are initialized
4. A "load" event is fired with the returned initial data

An application that requires authentication needs an extra step to handle unsuccessful logins.

Now let's look at the code:

``` javascript
// 1. load initial data from server
backend.call("init", conf.page).always(function(data) {

  // 2. construct API, we only create a User object on this demo
  self.user = new User(self, data ? data.user : {}, backend)

  // 3. all ready --> modules are loaded
  self.trigger("ready")

// init was successful
}).done(function(data) {

  // 4. load event
  self.trigger("load", data.view)

// init failed
}).fail(function() {

  // listen once when user logs in
  self.user.one("login", function(data) {
    $.extend(self.user, data.user)

    // 4b. fire a load event after successful login
    self.trigger("load", data.view)

  })

})
```

Application bootstrapping with user login is actually quite a complex thing to do, but the above flow is quite readable.


## API

Riot API is 3 things: an event library, a templating engine and a routing system.


### Events
Riot event system is in many ways similar to jQuery but there are 2 significant differences:

1) There is no [Event object](http://api.jquery.com/category/events/event-object/) because it's not relevant outside the DOM.

2) You can trigger and receive event arguments without wrapping them to an array.

#### riot.observable(el)

Adds an [Observer](http://en.wikipedia.org/wiki/Observer_pattern) support for the given object. After this the object is able to trigger and listen to events. For example:

``` js
function Car() {

  // Make Car instances observable
  var self = riot.observable(this)

  // listen to "start" event
  self.on("start", function() {
    // engine started
  })
}

// make a new Car instance
var car = new Car()

// trigger "start" event
car.trigger("start")
```


#### el.on(events, callback)

Listen to the given space separated list of `events` and execute the `callback` each time an event is triggered.

``` js
// listen to single event
el.on("start", function() {

})

// listen to multiple events, the event type is given as the argument
el.on("start stop", function(type) {

  // type is either "start" or "stop"

})
```


#### el.one(event, callback)

Listen to the given `event` and execute the `callback` at most once.

``` js
// run the function once, even if "start" is triggered multiple times
el.one("start", function() {

})
```

#### el.off(events)

Removes the given space separated list of event listeners

``` js
el.off("start stop")
```

#### el.off(event, fn)

Removes the given callback from the event array

``` js
function doStart() {
  console.info("starting")
}

el.on("start", doStart)

// remove a specific listener
el.off("start", doStart)
```



#### el.trigger(event)

Execute all callback functions that listen to the given `event`

``` js
el.trigger("start")
```

#### el.trigger(event, arg1 ... argN)

Execute all callback functions that listen to the given `event`. Any number of extra parameters can be provided for the listeners.

``` js
// listen to "start" event and expect extra arguments
el.on("start", function(engine_details, is_rainy_day) {

})

// trigger start event with extra parameters
el.trigger("start", { fuel: 89 }, true)

```


### Templating

Riot has an [exceptionally fast](../#templating) templating system to take your HTML markup and populating them with application data.

#### riot.render(template, data)

Take the `template` and return a string where all tokens (labels wrapped with curly braces) are replaced with the given `data`. For example


``` javascript
// simple render
riot.render("<h1>Hello {name}</h1>", { name: 'John' })

// render nested objects
riot.render("<h1>Hello {user.name}/h1>", { user: { name: 'John' } })
```

Both of the above will return `<h1>Hello John</h1>`. The template string cannot contain any logic due to [multiple reasons](#no-logic).


#### riot.render(template, data, true)

Same as `riot.render(template, data)` but all strings on the `data` are escaped as follows:

- `&` becomes `&amp;`
- `"` becomes `&quot;`
- `<` becomes `&lt;`
- `>` becomes `&gt;`

This prevents any XSS exploits on the data. Use this method if the data is provided by the end users or you don't oterwise have control over the data. The drawback is that this method is about 15 times slower than the above non-escaping counterpart.


``` javascript
// returns: "<h1>Hello &lt;freak&gt;</h1>"
riot.render("<h1>Hello {username}</h1>", { username: '<freak>' })
```


#### riot.render(template, data, fn)

Provide a custom function to transform the given `data`. For example:

``` javascript
// @- characters not allowed on username
riot.render("<h1>Hello {username}</h1>", { username: '@lolly' }, function(str, key) {
  if (key == 'username') return str.replace("@", "")
})
```


### Routing

#### riot.route(to)

Changes the browser URL and notifies all the listeners assigned with `riot.route(callback)` method below.

``` javascript
riot.route("#!/customers")
```

#### riot.route(callback)

Execute the given `callback` when the URL changes (via back button) or when `riot.route(to)` is called. The function is also called once upon page load – Riot makes sure this happens consistenly across browsers.

``` javascript
riot.route(function(hash) {
  // hash is a shortcut to location.hash
})
```

See how routing is [implemented](https://github.com/riot/riot
`script`-admin/blob/master/src/ui/view-switch.js) on our [demo application](../demo/).

Back button is supported on browsers with [history.pushState](http://caniuse.com/#feat=history) support. This includes all browsers except IE9 and below. On IE9 the feature falls back nicely and back button simply goes to previous page ignoring the changes on `location.hash`.


## Extensions

In the above example the `backend.call()` method returns a promise interface that is created with following `riot.observable` trick:

``` javascript
function Promise(fn) {
  var self = riot.observable(this)

  $.each(['done', 'fail', 'always'], function(i, name) {
    self[name] = function(arg) {
      return self[$.isFunction(arg) ? 'on' : 'trigger'](name, arg)
    }

  })

}
```

This is a generic observable implementation that you can take advantage of in any JavaScript application, not just in MVP configurations.

There is no specific extension mechanism in Riot. I think simple copy/pasteable functions are the best reusable components in JavaScript world. Riot itself is just 3 functions. They all extend the `$` namespace since it already exists on most websites (created on demand if it doesn't exist) and it's not cool to set global variables.

There is an unfortunate tendency to build unnecessary boilerplate around simple functionality (options, repositories, build systems etc...) while it could all be expressed with just one function. Simple functions are usable anywhere.

I'd love to see something like Gist but with better discoverability (search, tags etc.) A big mass of reusable functions that you can paste to your own project, perhaps modifying them to your needs a bit. Someone do that for us, please!


## Conclusion

Riot applications are smaller and they are written with vanilla JavaScript and jQuery. The business logic is completely separated and it has a nice API. All the functionality around the API is on isolated modules that can be developed independently. The API can be run and tested on the server side, and the application is fast because of the simple architecture and the logic free templating.

All the above concepts are applied on a well documented [demo application](../demo/). It's an administration panel that you can use as a starting point.

This documentation was a high level introduction to modular JavaScript programming but this is an ongoing process. The next update will add more detailed sections about Riot API, testing, building and deploying.


## Links

[1] [MVP passive view](http://martinfowler.com/eaaDev/PassiveScreen.html)

[2] [Riot templating is Fast](https://muut.com//blog/technology/riotjs-the-1kb-mvp-framework.html#fast)

[3] jQuery API implementations: [Zepto](http://zeptojs.com/), [Minified.js](http://minifiedjs.com/)

[4] [Usage statistics and marketshare of JQuery for websites](http://w3techs.com/technologies/details/js-jquery/all/all)

